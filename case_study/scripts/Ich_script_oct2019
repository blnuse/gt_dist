##  R script for pre/post burn surveys at Ichauway, Spring 2016.
##
##
##  Late Jul 2017
############################################

#####  I goofed in making the VIEW "ich.pre_post" in the goph db!  I somehow didn't allow for the possibility that there could've been burrows found in the first survey that weren't found in the second!!!  But in fact, there are a few such.  So I've now revised that VIEW in the db, and need to query it again:

library(RPostgreSQL)

conn <- dbConnect(drv="PostgreSQL", host="172.22.23.165", dbname="goph", user="gopherus", password="polyphemus")

ich <- dbGetQuery(conn,
                  "SELECT burrow_id, CASE WHEN found_pre IS NULL THEN 'N' ELSE found_pre END AS found_pre, CASE WHEN found_post IS NULL THEN 'N' ELSE found_post END AS found_post, diameter, tr_gid, dist
                     FROM ich.pre_post
                     ORDER BY 1")

tr.m <- as.numeric(dbGetQuery(conn, "SELECT ST_Length(ST_Union(geom)) AS length_m FROM ich.transcts"))

dbDisconnect(conn)
rm(conn)


ich$pre <- ifelse(ich$found_pre == "Y", 1, 0)
ich$post <- ifelse(ich$found_post == "Y", 1, 0)

#aug.mult <- 2
#aug <- dim(ich)[1]*aug.mult
#aug.burr <- as.data.frame(matrix(rep(c(NA,NA,NA,NA,NA,0,0), aug), byrow = T, nrow = aug))
#names(aug.burr) <- names(ich)

#ich.aug <- rbind(ich, aug.burr)
#diam <- c(ich$diameter, rep(ich$diameter, aug.mult))
##diam <- ich.aug$diameter
#dist <- ich.aug$dist

#y <- ich.aug[,c("pre", "post")]

#n.obs <- dim(ich)[1]
#M <- dim(ich.aug)[1]



#frm.ha <- as.numeric(dbGetQuery(conn, "SELECT ST_Area(ST_Union(geom))/10000 AS area_ha FROM ich.samp_fr"))

#Bx <- c(max(dist[ich.aug$pre==1], na.rm=T),
#        max(dist, na.rm=T))


#ltds.area <- 2*Bx*tr.m/10000

#max.diam <- c(max(diam[ich.aug$pre==1], na.rm=T),
#        max(diam, na.rm=T))

#p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
#                rep(seq(from = 0, to = 25, by = 5), times = 4))
#colnames(p.vals) <- c("diam", "dist")


#############################
#want <- c("Bx", "ltds.area", "frm.ha", "y", "diam", "max.diam", "dist", "n.obs", "M", "p.vals")
#dat.lst <- mget(want)

# save(dat.lst, file = "/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/R/ich_data.R")






#setwd("/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/R")
#load("ich_data.R")

multr <- 3
############################################


pre.lst <- list()

pre.lst$n.obs <- sum(ich$pre)
pre.lst$M <- (multr+1)*pre.lst$n.obs
h.pre <- hist(ich$diam[ich$pre == 1])
pre.lst$diam.hist <- h.pre$counts/sum(h.pre$counts)
pre.lst$diam <- c(ich$diam[ich$pre == 1], rep(NA, multr*pre.lst$n.obs))
pre.lst$dist <- c(ich$dist[ich$pre == 1], rep(NA, multr*pre.lst$n.obs))
pre.lst$y <- c(ich$pre[ich$pre == 1], rep(0, multr*pre.lst$n.obs))
pre.lst$Bx <- max(pre.lst$dist, na.rm = T)
pre.lst$max.diam <- max(pre.lst$diam, na.rm = T)
pre.lst$p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
                         rep(seq(from = 0, to = 25, by = 5), times = 4))
pre.lst$surv.len <- tr.m

#################################

#########  Another important step:  take assumed burrow distribution from Post-burn burrows that are very near the line!  For use with models ending in "_nearBurr"
dat.near <- list()
ich.or <- ifelse(ich$pre == 1 | ich$post == 1, 1, 0)
h <- hist(ich$diam[ich$dist <= 5])
dat.near$burr.near <- h$counts/sum(h$counts)
dat.near$M <- (multr+1)*nrow(ich)
dat.near$y <- rbind(ich[,c("pre","post")],
                  matrix(c(0,0), ncol = 2, nrow = multr*nrow(ich), dimnames = list(NULL, c("pre","post"))))
dat.near$y.or <- c(rep(1, nrow(ich)), rep(NA, multr*nrow(ich)))
dat.near$dist <- c(ich$dist[1:nrow(ich)], rep(NA, multr*nrow(ich)))
dat.near$diam <- c(ich$diam[1:nrow(ich)], rep(NA, multr*nrow(ich)))
dat.near$p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
                         rep(seq(from = 0, to = 25, by = 5), times = 4))
colnames(dat.near$p.vals) <- c("diam", "dist")
dat.near$max.diam <- c(max(ich$diam[ich$pre == 1], na.rm = T),
                       max(ich$diam[ich$post == 1], na.rm = T))
dat.near$Bx <- c(max(ich$dist[ich$pre == 1], na.rm = T),
                       max(ich$dist[ich$post == 1], na.rm = T))
dat.near$surv.len <- tr.m

##########  Try larger M, on full dataset:
#dat.m4 <- dat.lst

#mult <- 4
#dat.m4$M <- (mult+1)*dat.lst$n.obs
#dat.m4$y <- rbind(dat.lst$y[1:dat.lst$n.obs,],
#                  matrix(c(0,0), ncol = 2, nrow = mult*dat.lst$n.obs, dimnames = list(NULL, names(dat.lst$y))))
#dat.m4$y.or <- c(dat.lst$y.or[1:dat.lst$n.obs], rep(0, mult*dat.lst$n.obs))
#dat.m4$dist <- c(dat.lst$dist[1:dat.lst$n.obs], rep(NA, mult*dat.lst$n.obs))
#dat.m4$diam <- rep(dat.lst$diam[1:dat.lst$n.obs], mult+1)


#########  Now, make the augmented burrows in the pre- survey follow the distribution of those observed within 5m of the line (i.e., those found in the pre- survey)!
pre.near <- pre.lst
h.pre.near <- hist(pre.near$diam[pre.near$dist <= 5])
pre.near$burr.near <- h.pre.near$counts/sum(h.pre.near$counts)



Henderquote:
"You look _cute_!" (kuhyooohrt)
"I'm more productive when I look cute." 
                
#############################################################################################
###############################  Function !!!  ###########################################
#############################################################################################


###  modernize this 29jul2019:
runfun <- function(modl, datl, initl, iter.samp, vars, pre = T, post = F, name.suffix = "") { 
      stopifnot(pre || post)
#      require(foreach)
#      require(doParallel)
      require(parallel); n.cores <- 4; options(mc.cores = n.cores)

      require(rjags); load.module("glm"); load.module("dic"); load.module("lecuyer")

jags.fun <- function (l) {
  init.fun <- function() {
    list(.RNG.state = l$.RNG.state,
         .RNG.name = l$.RNG.name,
         w = unlist(initl$w))
  }
  
#  dat.tmp <- c(l$dat, list(max.grp = l$max.grp))
  jm <- jags.model(file=l$file.nm, inits=init.fun(), data=l$dat, n.chains=1) #inits=init.lst,
  update(jm, n.iter=l$iter.burn)
  js <- coda.samples(jm, var=l$var, n.iter=l$iter.samp)
#  ds <- dic.samples(jm, n.iter=l$iter, type = "pD")   #  don't need for this version, where max.grp always = n.spp!
  return(js) #, dic=ds))
}


  rnd <- parallel.seeds("lecuyer::RngStream", n.cores)

  jl.unit <- list(iter.burn = iter.samp,
                  iter.samp = iter.samp,
                  var = vars,
                  dat = datl,
                  file.nm = paste0("/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/JAGS/newer/current/", modl))
  
  jl <- lapply(rnd, FUN=c, jl.unit)                 
                  
time <- system.time(
  out <- mclapply(jl, FUN=jags.fun)  ## mclapply() parallelizes this!
)
  
  out <- mcmc.list(sapply(out, FUN = `[[`, 1, simplify=F))

#  return(out)
#}
  s <- summary(out)

  save(datl, time, out, s, file = paste0("/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/output/current/", modl, name.suffix, ".R"))

  if (pre && !post) { p.pre <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p.pred", fixed = T), c(1,3,5)] }
  if (post && !pre) { p.post <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p.pred", fixed = T), c(1,3,5)] }
  if (pre && post) {
    p.pre <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p\\.pred\\[[0-9]{1,2},1\\]", fixed = F), c(1,3,5)]
    p.post <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p\\.pred\\[[0-9]{1,2},2\\]", fixed = F), c(1,3,5)]
  }

png(file=paste0("/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/figs/oct2019/", modl, name.suffix, ".png"), res=300, height = 7, width = 10, units="in")
par(mfrow = c(2,2), oma = c(3.5,3.5,1,1), mar = c(0,0,0,0), xaxs="i", yaxs = "i")

  lg <- rgb(t(col2rgb("lightgrey")/255), alpha = 0.5)
  lc <- rgb(t(col2rgb("lightcyan2")/255), alpha = 0.5)
    
for (i in 1:4) { 

with(datl,
  { tst <- p.vals[,1] == 10*i

    if (pre) { poly.pre <- cbind(c(p.vals[tst,2], rev(p.vals[tst,2])), c(p.pre[tst,1], rev(p.pre[tst,3]))) } 
    if (post) { poly.post <- cbind(c(p.vals[tst,2], rev(p.vals[tst,2])), c(p.post[tst,1], rev(p.post[tst,3]))) }

    if (pre) { plot(p.vals[tst,2], p.pre[tst,2], ylim = c(0,1), type="n", main = "", ylab = "", xlab = "", xaxt = "n", yaxt = "n")
    } else {
      plot(p.vals[tst,2], p.post[tst,2], ylim = c(0,1), type="n", main = "", ylab = "", xlab = "", xaxt = "n", yaxt = "n")
    }
    
    if (pre) { polygon(poly.pre, col = lg, border = NA) }
    if (post) { polygon(poly.post, col = lc, border = NA) }
  
    if (pre) { lines(p.vals[tst,2], p.pre[tst,2], col = "black") }
    if (post) { lines(p.vals[tst,2], p.post[tst,2], col = "blue") }

    u <- par("usr")
    text(x = u[1] + 0.85*(u[2]-u[1]), y = u[3] + 0.85*(u[4]-u[3]), labels = paste(10*i, "cm"), cex = 1.3, font = 2)
    axis(side = 1, at = if (i %in% c(1,3)) {seq(0,20,5)} else {seq(5,25,5)}, labels = ifelse(i %in% 1:2, F, T), tcl = 0.5, padj = -1, lwd = 0, lwd.ticks = 1)
    axis(side = 2, at = if (i %in% c(1,2)) {seq(0.2,1,0.2)} else {seq(0,0.8,0.2)}, labels = ifelse(i %in% c(1,3), T, F), tcl = 0.5, padj = 1, lwd = 0, lwd.ticks = 1)
    axis(side = 3, labels = F, tcl = 0.5, lwd = 0, lwd.ticks = 1)
    axis(side = 4, labels = F, tcl = 0.5, lwd = 0, lwd.ticks = 1)
  })


      
  if (i == 4) {
    l <- legend(x = 3, y = 0.1, yjust = 0, lty = 1, legend = c("Pre-burn", "Post-burn"), plot = F)
    if (pre) { leg.poly.pre <- cbind(l$text$x[1] + c(-0.3, -0.1, -0.1, -0.3)*l$rect$w,
                          l$text$y[1] + c(0.1, 0.1, -0.1, -0.1)*l$rect$h)
               polygon(leg.poly.pre, col = lg, border = NA) }
    if (post) { leg.poly.post <- cbind(l$text$x[2] + c(-0.3, -0.1, -0.1, -0.3)*l$rect$w, l$text$y[2] + c(0.1, 0.1, -0.1, -0.1)*l$rect$h)
                polygon(leg.poly.post, col = lc, border = NA) }

    legend(x = 3, y = 0.1, yjust = 0, lty = 1, col = c("black", "blue"), legend = c("Pre-burn", "Post-burn"), bg = NULL)
  }
}

mtext(side = 1, line = 2.5, text = "Distance (m)", outer = T)
mtext(side = 2, line = 2.5, text = "Detection probability", outer = T)


dev.off()

return(mget(c("time", "s")))
}

#############################################################################################
###############################  END Function !!!  #######################################
#############################################################################################

##  HEY!
##  HEY! HEY!
##  HEY! HEY! HEY!
#######  Stuff here has been modified October 2019!!! #######################
##  HEY! HEY! HEY!
##  HEY! HEY!
##  HEY!

###  Here are the model/data combinations from the Table in the MS:
both_Int
both_IntSc (intercept- and scale-varying)
pre_Int_30 (xi_brk > 30 and xi_int < 0.5)
pre_Int
pre_IntSc
pre_Conv

Also add a run on the Pre data, but using the burrow width distribution (within 5m of the line) from the Post survey!  This to be compared with pre_Int30 above.






##  There are going to be a number of models fit here -- re-runs 29 jul 2019!
##  All results files in: /home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/output/sep/oct2019/

##############################################################################################################
##############################################################################################################
#6b.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
#     Model:  "both_Int"
outp <- runfun(modl = "joint_analysis_revised_xi",
               datl = dat.near,
               initl = list(w = dat.near$y.or),
               iter.samp = 5000,
               vars <- c("xi.5",
                  "xi.break",
                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
                  "sigma",
                  "deviance",
                  "D", "xi.pred", "p.pred"),
               pre = T,
               post = T)


##############################################################################################################
##############################################################################################################
#7.  Descr: Use xi and tau: xi.int, xi.break, tau.int and tau.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
#     Model:  both_sameSigma_xiFree_ver2
outp <- runfun(modl = "joint_analysis_revised_tau",
               datl = dat.near,
               initl = list(w = dat.near$y.or),
               iter.samp = 5000,
               vars = c("xi.5",
                  "xi.break",
                  "xi.beta",
                  "tau.5",
                  "tau.break",
                  "tau.beta",
                  "sigma",
                  "deviance",
                  "D", "xi.pred", "tau.pred", "p.pred"),
               pre = T,
               post = T)

#modl = "joint_analysis_revised_tau"
#               datl = dat.near
#               initl = list(w = dat.near$y.or)
#               iter.samp = 5000
#               vars = c("xi.5",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.5",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "D", "xi.pred", "p.pred")
#               pre = T
#               post = T

##############################################################################################################
##############################################################################################################
## 1.  Pretend we only have pre-burn survey:

#1a.  Descr: Use xi scalar, constrain xi.brk to be >= 30cm AND xi.int to be  <= 0.5 !
#     Model:  pre_Xi

outp <- runfun(modl = "pre_xi_xiBrk_gt30",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))

##############################################################################################################
##############################################################################################################
###  try the Nested Doll model on the pre-burn dataset, with xi.brk <= 30....
outp <- runfun(modl = "pre_doll_gt30",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))
###  eh, not much difference....

##############################################################################################################
##############################################################################################################
###  Now try the "xiFree" (intercept-varying) model on the pre-burn dataset, with xi.brk <= 30 AND with augmented burrows distributed like those found within 5m of transect!....
outp <- runfun(modl = "pre_xi_xiBrkGt30_nearBurr",
               datl = pre.near,
               initl = list(w = pre.near$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))
###  OK, this didn't make a huge difference -- in fact, it reduced N relative to the model above, "pre_doll_gt30".

##############################################################################################################
##############################################################################################################
###  Try re-doing the basic "pre_xi" model, but using the histogram for defining the diameters of augmented burrows, rather than the "scramble-up"  method used previously....
outp <- runfun(modl = "pre_xi",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))

###  For table in MS:
N <- outp$s$quantiles[grep(rownames(outp$s$quantiles), pattern = "N", fixed = T),c(1,3,5)]
xi.int <- outp$s$quantiles[grep(rownames(outp$s$quantiles), pattern = "xi.int", fixed = T),c(1,3,5)]
xi.brk <- outp$s$quantiles[grep(rownames(outp$s$quantiles), pattern = "xi.break", fixed = T),c(1,3,5)]
sigma <- outp$s$quantiles[grep(rownames(outp$s$quantiles), pattern = "sigma", fixed = T),c(1,3,5)]


##############################################################################################################
##############################################################################################################
###  Now re-do the "pre_xi_tau" model, using the histogram for defining the diameters of augmented burrows...
outp <- runfun(modl = "pre_xi_tau",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "tau.int",
                  "tau.break",
                  "tau.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))

##############################################################################################################
##############################################################################################################
###  And the conventional distance analysis, "pre_noXi", but using the histogram...
outp <- runfun(modl = "pre_noXi",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))


##############################################################################################################
###  And finally, the "pre_xi" model, but with xi.int and xi.brk constrained to the credible intervals from the joint analysis 'intercept-varying' model... 
outp <- runfun(modl = "pre_xi_fix",
               datl = pre.lst,
               initl = list(w = pre.lst$y),
               iter.samp = 5000,
               vars = c("xi.int",
                  "xi.break",
                  "xi.beta",
                  "sigma",
                  "deviance",
                  "N", "xi.pred", "p.pred"))










### 1.  Pretend we only have pre-burn survey:

##1a.  Descr: Use xi scalar, but don't constrain it at all.
##     Model:  pre_Xi

#outp <- runfun(modl = "pre_Xi",
#               datl = pre.lst,
#               initl = list(w = pre.lst$y),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred"))

##1b.  Descr: Straight distance analysis, no xi or tau.
##     Model:  pre_noXi


#outp <- runfun(modl = "pre_noXi",
#               datl = pre.lst,
#               initl = list(w = pre.lst$y),
#               vars = c("sigma",
#                        "deviance",
#                        "N", "p.pred"))

##1c.  Descr: Use xi and tau scalars, but don't constrain them at all.
##     Model:  pre_xi_tau

#outp <- runfun(modl = "pre_xi_tau",
#               datl = pre.lst,
#               initl = list(w = pre.lst$y),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"))


############################################################################
############################################################################
#####  Post-burn only!

##2a.  Descr: Post-burn only; no xi or tau scalars.
##     Model:  post_noXi
#outp <- runfun(modl = "post_noXi",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c(
#                  "sigma",
#                  "deviance",
#                  "N", "p.pred"),
#               pre = F,
#               post = T)

##2b.  Descr: Use xi scalar.
##     Model:  post_xi
#outp <- runfun(modl = "post_xi",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred"),
#               pre = F,
#               post = T)

##2c.  Descr: Use xi and tau scalars.
##     Model:  post_xi_tau
#outp <- runfun(modl = "post_xi_tau",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"),
#               pre = F,
#               post = T)
#                             
############################################################################
############################################################################
###  Pre- and post-burn together.

##3a.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys.
##     Model:  both_sameSigma_xiFree
#outp <- runfun(modl = "both_sameSigma_xiFree",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "xi.rat",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T)

##3a-2.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_ver2",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "xi.rat",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T)

##Conclusion:  this one just doesn't look right.

##3a-3.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_ver2b",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "mult"),
#               pre = T,
#               post = T)

##Conclusion:  nope.

##3a-3.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_ver3",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "mult"),
#               pre = T,
#               post = T)
#               


##3a-4.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_ver4",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "mult"),
#               pre = T,
#               post = T)
#               
#                              

##3b.  Descr: Use xi in both surveys:  now xi.int for the second survey is constrained between 0.9 and 1.
##     Model:  both_sameSigma_xiGT90
#outp <- runfun(modl = "both_sameSigma_xiGT90",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "xi.rat",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T)

##3c.  Descr: Use xi and tau in both surveys:  both totally free.
##     Model:  both_sameSigma_xiFree_tauFree
#outp <- runfun(modl = "both_sameSigma_xiFree_tauFree",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred", "xi.rat", "tau.rat", "p.rat"),
#               pre = T,
#               post = T)
#                

##3d.  Descr: Use xi and tau in both surveys:  all free but xi.int in post-burn, which is > 0.9.
##     Model:  both_sameSigma_xiGT90_tauFree
#outp <- runfun(modl = "both_sameSigma_xiGT90_tauFree",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred", "xi.rat", "tau.rat", "p.rat"),
#               pre = T,
#               post = T)


##3e.  Descr: Use xi and tau in both surveys:  all free but xi.int in post-burn, which is = 1.
##     Model:  both_sameSigma_xi1_tauFree
#outp <- runfun(modl = "both_sameSigma_xi1",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T)
#               
#               
##3f.  Descr: Use xi and tau in both surveys:  all free but xi.int in post-burn, which is = 1.
##     Model:  both_sameSigma_xi1_tauFree
#outp <- runfun(modl = "both_sameSigma_xi1_tauFree",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred", "xi.rat", "tau.rat", "p.rat"),
#               pre = T,
#               post = T)
#               
########################################################

############################################################################
############################################################################
###  "Near burr" burrow size distribution: Pre- and post-burn together.

##4a.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys.
##     Model:  both_sameSigma_xiFree
#outp <- runfun(modl = "both_sameSigma_xiFree_nearBurr",
#               datl = dat.near,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "xi.rat",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T)



############################################################################
############################################################################
############################################################################
############################################################################
###  Increased M: Pre- and post-burn together.

##4a.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys.
##     Model:  both_sameSigma_xiFree
#outp <- runfun(modl = "both_sameSigma_xiFree",
#               datl = dat.m4,
#               initl = list(w = dat.m4$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "xi.rat",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "p.pred", "xi.rat", "p.rat"),
#               pre = T,
#               post = T,
#               name.suffix = "_m4")

###  Increasing M, in itself, doesn't seem to alter the results much at all:
##                   2.5%       25%       50%       75%     97.5%
##N             5.570e+02 5.880e+02 6.060e+02 6.260e+02 6.710e+02

##compared to smaller M:
##                   2.5%       25%       50%       75%     97.5%
##N             5.570e+02 5.880e+02 6.060e+02 6.260e+02 6.710e+02


############################################################################
############################################################################
###  Xi estimated from pre- only; tau estimated from post-burn only.

##5.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiPre_tauPost",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"),
#               pre = T,
#               post = T)
#               

##6.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_pRat",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
##                  "tau.int",
##                  "tau.break",
##                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"),
#               pre = T,
#               post = T)


#               
##7.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_tauFree_pRat",
#               datl = dat.lst,
#               initl = list(w = dat.lst$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"),
#               pre = T,
#               post = T)

###  Next, try the above model with the burr.near dataset!....

##7b.  Descr: Use xi: xi.int and xi.break are totally free, in both surveys. This version tries to make p[i,1] = Pr (obs Pre) rather than p[i,1] = Pr (obs Pre | obs Post).
##     Model:  both_sameSigma_xiFree_ver2
#outp <- runfun(modl = "both_sameSigma_xiFree_tauFree_pRat_nearBurr",
#               datl = dat.near,
#               initl = list(w = dat.near$y[,2]),
#               vars <- c("xi.int",
#                  "xi.break",
#                  "xi.beta",
#                  "tau.int",
#                  "tau.break",
#                  "tau.beta",
#                  "sigma",
#                  "deviance",
#                  "N", "xi.pred", "tau.pred", "p.pred"),
#               pre = T,
#               post = T)


#               
### Raw, observed:
#png(file="/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/figs/sep/raw_size.png", res=300, height = 7, width = 10, units="in")
#brk <- seq(0, 40, by = 2)
#par(mfcol = c(3,2))
#with(dat.lst,
#{
# hist(dist[y[,1] == 1], xlim = c(0,40), ylim = c(0, 60), main = "Pre-burn: all burrows", xlab = "Distance (m)", breaks = brk)
# hist(dist[y[,1] == 1 & diam > 30], xlim = c(0,40), ylim = c(0, 60), main = "Pre-burn: burrows > 30 cm wide", xlab = "Distance (m)", breaks = brk)
# hist(dist[y[,1] == 1 & diam < 20], xlim = c(0,40), ylim = c(0, 25), main = "Pre-burn: burrows < 20 cm wide", xlab = "Distance (m)", breaks = brk)
# hist(dist[y[,2] == 1], xlim = c(0,40), ylim = c(0, 60), main = "Post-burn: all burrows", xlab = "Distance (m)", breaks = brk)
# hist(dist[y[,2] == 1 & diam > 30], xlim = c(0,40), ylim = c(0, 60), main = "Post-burn: burrows > 30 cm wide", xlab = "Distance (m)", breaks = brk)
# hist(dist[y[,2] == 1 & diam < 20], xlim = c(0,40), ylim = c(0, 25), main = "Post-burn: burrows < 20 cm wide", xlab = "Distance (m)", breaks = brk)
#})
#dev.off()

