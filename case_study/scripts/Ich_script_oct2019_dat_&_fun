##  R script for pre/post burn surveys at Ichauway, Spring 2016.
##
##
##  Late Jul 2017
############################################

#####  I goofed in making the VIEW "ich.pre_post" in the goph db!  I somehow didn't allow for the possibility that there could've been burrows found in the first survey that weren't found in the second!!!  But in fact, there are a few such.  So I've now revised that VIEW in the db, and need to query it again:

library(RPostgreSQL)

conn <- dbConnect(drv="PostgreSQL", host="172.22.23.165", dbname="goph", user="gopherus", password="polyphemus")

ich <- dbGetQuery(conn,
                  "SELECT burrow_id, CASE WHEN found_pre IS NULL THEN 'N' ELSE found_pre END AS found_pre, CASE WHEN found_post IS NULL THEN 'N' ELSE found_post END AS found_post, diameter, tr_gid, dist
                     FROM ich.pre_post
                     ORDER BY 1")

tr.m <- as.numeric(dbGetQuery(conn, "SELECT ST_Length(ST_Union(geom)) AS length_m FROM ich.transcts"))

dbDisconnect(conn)
rm(conn)


ich$pre <- ifelse(ich$found_pre == "Y", 1, 0)
ich$post <- ifelse(ich$found_post == "Y", 1, 0)

#aug.mult <- 2
#aug <- dim(ich)[1]*aug.mult
#aug.burr <- as.data.frame(matrix(rep(c(NA,NA,NA,NA,NA,0,0), aug), byrow = T, nrow = aug))
#names(aug.burr) <- names(ich)

#ich.aug <- rbind(ich, aug.burr)
#diam <- c(ich$diameter, rep(ich$diameter, aug.mult))
##diam <- ich.aug$diameter
#dist <- ich.aug$dist

#y <- ich.aug[,c("pre", "post")]

#n.obs <- dim(ich)[1]
#M <- dim(ich.aug)[1]



#frm.ha <- as.numeric(dbGetQuery(conn, "SELECT ST_Area(ST_Union(geom))/10000 AS area_ha FROM ich.samp_fr"))

#Bx <- c(max(dist[ich.aug$pre==1], na.rm=T),
#        max(dist, na.rm=T))


#ltds.area <- 2*Bx*tr.m/10000

#max.diam <- c(max(diam[ich.aug$pre==1], na.rm=T),
#        max(diam, na.rm=T))

#p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
#                rep(seq(from = 0, to = 25, by = 5), times = 4))
#colnames(p.vals) <- c("diam", "dist")


#############################
#want <- c("Bx", "ltds.area", "frm.ha", "y", "diam", "max.diam", "dist", "n.obs", "M", "p.vals")
#dat.lst <- mget(want)

# save(dat.lst, file = "/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn/R/ich_data.R")






setwd("/home/nuse/Projects/GT_stuff/distance/Ichauway_pre_post_burn")
#load("ich_data.R")

multr <- 5
############################################


pre.lst <- list()

pre.lst$n.obs <- sum(ich$pre)
pre.lst$M <- (multr+1)*pre.lst$n.obs
h.pre <- hist(ich$diam[ich$pre == 1], plot = F)
pre.lst$diam.hist <- h.pre$counts/sum(h.pre$counts)
pre.lst$diam <- c(ich$diam[ich$pre == 1], rep(NA, multr*pre.lst$n.obs))
pre.lst$dist <- c(ich$dist[ich$pre == 1], rep(NA, multr*pre.lst$n.obs))
pre.lst$y <- matrix(c(ich$pre[ich$pre == 1], rep(0, multr*pre.lst$n.obs)), ncol = 1)
pre.lst$Bx <- max(pre.lst$dist, na.rm = T)
pre.lst$max.diam <- max(pre.lst$diam, na.rm = T)
pre.lst$p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
                         rep(seq(from = 0, to = 25, by = 5), times = 4))
pre.lst$surv.len <- tr.m

#################################

#########  Another important step:  take assumed burrow distribution from Post-burn burrows that are very near the line!  For use with models ending in "_nearBurr"
dat.near <- list()
ich.or <- ifelse(ich$pre == 1 | ich$post == 1, 1, 0)
h <- hist(ich$diam[ich$dist <= 5], plot = F)
dat.near$burr.near <- h$counts/sum(h$counts)
dat.near$M <- (multr+1)*nrow(ich)
dat.near$y <- rbind(ich[,c("pre","post")],
                  matrix(c(0,0), ncol = 2, nrow = multr*nrow(ich), dimnames = list(NULL, c("pre","post"))))
dat.near$y.or <- c(rep(1, nrow(ich)), rep(NA, multr*nrow(ich)))
dat.near$dist <- c(ich$dist[1:nrow(ich)], rep(NA, multr*nrow(ich)))
dat.near$diam <- c(ich$diam[1:nrow(ich)], rep(NA, multr*nrow(ich)))
dat.near$p.vals <- cbind(rep(seq(from = 10, to = 40, by = 10), each = 6),
                         rep(seq(from = 0, to = 25, by = 5), times = 4))
colnames(dat.near$p.vals) <- c("diam", "dist")
dat.near$max.diam <- c(max(ich$diam[ich$pre == 1], na.rm = T),
                       max(ich$diam[ich$post == 1], na.rm = T))
dat.near$Bx <- c(max(ich$dist[ich$pre == 1], na.rm = T),
                       max(ich$dist[ich$post == 1], na.rm = T))
dat.near$surv.len <- tr.m

##########  Try larger M, on full dataset:
#dat.m4 <- dat.lst

#mult <- 4
#dat.m4$M <- (mult+1)*dat.lst$n.obs
#dat.m4$y <- rbind(dat.lst$y[1:dat.lst$n.obs,],
#                  matrix(c(0,0), ncol = 2, nrow = mult*dat.lst$n.obs, dimnames = list(NULL, names(dat.lst$y))))
#dat.m4$y.or <- c(dat.lst$y.or[1:dat.lst$n.obs], rep(0, mult*dat.lst$n.obs))
#dat.m4$dist <- c(dat.lst$dist[1:dat.lst$n.obs], rep(NA, mult*dat.lst$n.obs))
#dat.m4$diam <- rep(dat.lst$diam[1:dat.lst$n.obs], mult+1)


#########  Now, make the augmented burrows in the pre- survey follow the distribution of those observed within 5m of the line (i.e., those found in the pre- survey)!
pre.near <- pre.lst
h.pre.near <- hist(pre.near$diam[pre.near$dist <= 5], plot = F)
pre.near$burr.near <- h.pre.near$counts/sum(h.pre.near$counts)

#########  Now, make the augmented burrows in the pre- survey follow the distribution of those observed within 5m of the line (i.e., those found in the post- survey)!
pre.nrPst <- pre.lst
pre.nrPst$burr.near <- dat.near$burr.near


#Henderquote:
#"You look _cute_!" (kuhyooohrt)
#"I'm more productive when I look cute." 
                
#############################################################################################
###############################  Function !!!  ###########################################
#############################################################################################


###  modernize this 29jul2019:
runfun <- function(modl, datl, initl, iter.samp, vars, max.xi.5, min.xi.brk, pre = T, post = F, name.suffix = "") { 
      stopifnot(pre || post)
#      require(foreach)
#      require(doParallel)
      require(parallel); n.cores <- 4; options(mc.cores = n.cores)

      require(rjags); load.module("glm"); load.module("dic"); load.module("lecuyer")

jags.fun <- function (l) {
  init.fun <- function() {
    list(.RNG.state = l$.RNG.state,
         .RNG.name = l$.RNG.name,
         w = unlist(initl$w))
  }
  
#  dat.tmp <- c(l$dat, list(max.grp = l$max.grp))
  jm <- jags.model(file=l$file.nm, inits=init.fun(), data=c(l$dat, min.xi.brk = min.xi.brk, max.xi.5 = max.xi.5), n.chains=1) #inits=init.lst,
  update(jm, n.iter=l$iter.burn)
  js <- coda.samples(jm, var=l$var, n.iter=l$iter.samp)
#  ds <- dic.samples(jm, n.iter=l$iter, type = "pD")   #  don't need for this version, where max.grp always = n.spp!
  return(js) #, dic=ds))
}


  rnd <- parallel.seeds("lecuyer::RngStream", n.cores)

  jl.unit <- list(iter.burn = iter.samp,
                  iter.samp = iter.samp,
                  var = vars,
                  dat = datl,
                  file.nm = paste0("./JAGS/newer/current/", modl))
  
  jl <- lapply(rnd, FUN=c, jl.unit)                 
                  
time <- system.time(
  out <- mclapply(jl, FUN=jags.fun)  ## mclapply() parallelizes this!
)
  
  out <- mcmc.list(sapply(out, FUN = `[[`, 1, simplify=F))

#  return(out)
#}
  s <- summary(out)

  save(datl, time, out, s, file = paste0("./output/current/", modl, name.suffix, ".R"))

  if (pre && !post) { p.pre <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p.pred", fixed = T), c(1,3,5)] }
  if (post && !pre) { p.post <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p.pred", fixed = T), c(1,3,5)] }
  if (pre && post) {
    p.pre <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p\\.pred\\[[0-9]{1,2},1\\]", fixed = F), c(1,3,5)]
    p.post <- s$quantiles[grep(x = rownames(s$quantiles), pattern = "p\\.pred\\[[0-9]{1,2},2\\]", fixed = F), c(1,3,5)]
  }

png(file=paste0("./figs/oct2019/", modl, name.suffix, ".png"), res=300, height = 7, width = 10, units="in")
par(mfrow = c(2,2), oma = c(3.5,3.5,1,1), mar = c(0,0,0,0), xaxs="i", yaxs = "i")

  lg <- rgb(t(col2rgb("lightgrey")/255), alpha = 0.5)
  lc <- rgb(t(col2rgb("lightcyan2")/255), alpha = 0.5)
    
for (i in 1:4) { 

with(datl,
  { tst <- p.vals[,1] == 10*i

    if (pre) { poly.pre <- cbind(c(p.vals[tst,2], rev(p.vals[tst,2])), c(p.pre[tst,1], rev(p.pre[tst,3]))) } 
    if (post) { poly.post <- cbind(c(p.vals[tst,2], rev(p.vals[tst,2])), c(p.post[tst,1], rev(p.post[tst,3]))) }

    if (pre) { plot(p.vals[tst,2], p.pre[tst,2], ylim = c(0,1), type="n", main = "", ylab = "", xlab = "", xaxt = "n", yaxt = "n")
    } else {
      plot(p.vals[tst,2], p.post[tst,2], ylim = c(0,1), type="n", main = "", ylab = "", xlab = "", xaxt = "n", yaxt = "n")
    }
    
    if (pre) { polygon(poly.pre, col = lg, border = NA) }
    if (post) { polygon(poly.post, col = lc, border = NA) }
  
    if (pre) { lines(p.vals[tst,2], p.pre[tst,2], col = "black") }
    if (post) { lines(p.vals[tst,2], p.post[tst,2], col = "blue") }

    u <- par("usr")
    text(x = u[1] + 0.85*(u[2]-u[1]), y = u[3] + 0.85*(u[4]-u[3]), labels = paste(10*i, "cm"), cex = 1.3, font = 2)
    axis(side = 1, at = if (i %in% c(1,3)) {seq(0,20,5)} else {seq(5,25,5)}, labels = ifelse(i %in% 1:2, F, T), tcl = 0.5, padj = -1, lwd = 0, lwd.ticks = 1)
    axis(side = 2, at = if (i %in% c(1,2)) {seq(0.2,1,0.2)} else {seq(0,0.8,0.2)}, labels = ifelse(i %in% c(1,3), T, F), tcl = 0.5, padj = 1, lwd = 0, lwd.ticks = 1)
    axis(side = 3, labels = F, tcl = 0.5, lwd = 0, lwd.ticks = 1)
    axis(side = 4, labels = F, tcl = 0.5, lwd = 0, lwd.ticks = 1)
  })


      
  if (i == 4) {
    l <- legend(x = 3, y = 0.1, yjust = 0, lty = 1, legend = c("Pre-burn", "Post-burn"), plot = F)
    if (pre) { leg.poly.pre <- cbind(l$text$x[1] + c(-0.3, -0.1, -0.1, -0.3)*l$rect$w,
                          l$text$y[1] + c(0.1, 0.1, -0.1, -0.1)*l$rect$h)
               polygon(leg.poly.pre, col = lg, border = NA) }
    if (post) { leg.poly.post <- cbind(l$text$x[2] + c(-0.3, -0.1, -0.1, -0.3)*l$rect$w, l$text$y[2] + c(0.1, 0.1, -0.1, -0.1)*l$rect$h)
                polygon(leg.poly.post, col = lc, border = NA) }

    legend(x = 3, y = 0.1, yjust = 0, lty = 1, col = c("black", "blue"), legend = c("Pre-burn", "Post-burn"), bg = NULL)
  }
}

mtext(side = 1, line = 2.5, text = "Distance (m)", outer = T)
mtext(side = 2, line = 2.5, text = "Detection probability", outer = T)


dev.off()

return(mget(c("time", "s")))
}

#############################################################################################
###############################  END Function !!!  #######################################
#############################################################################################
